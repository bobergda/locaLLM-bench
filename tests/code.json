[
    {
    "prompt": "Provide Python code for a function is_palindrome(s: str) that returns True if s reads the same forwards and backwards, ignoring case and spaces. Return only the function code.",
    "code_tests": [
      { "assert": "is_palindrome('Kajak')" },
      { "assert": "is_palindrome('test') is False" },
      { "assert": "is_palindrome('Never odd or even')" },
      { "assert": "is_palindrome('A b a')" }
    ]
  },
  {
    "prompt": "Write a function merge_sorted(a: list[int], b: list[int]) -> list[int] that merges two already-sorted ascending lists into one sorted list without using sort(). Return only the function code.",
    "code_tests": [
      { "assert": "merge_sorted([1,3,5], [2,4,6]) == [1,2,3,4,5,6]" },
      { "assert": "merge_sorted([], [1,2]) == [1,2]" },
      { "assert": "merge_sorted([0,0,1], [0,2]) == [0,0,0,1,2]" }
    ]
  },
  {
    "prompt": "Write a function char_histogram(text: str) -> dict[str, int] that counts lowercase alphabetic characters, ignoring spaces and punctuation. Return only the function code.",
    "code_tests": [
      { "assert": "char_histogram('Hello') == {'h':1,'e':1,'l':2,'o':1}" },
      { "assert": "char_histogram('Never odd or even!') == {'n':2,'e':4,'v':2,'r':2,'o':2,'d':2}" },
      { "assert": "char_histogram('') == {}" }
    ]
  },
  {
    "prompt": "Python: write a function sum_even(nums: list[int]) that returns the sum of even integers. Return only the function code.",
    "code_tests": [
      { "assert": "sum_even([1, 2, 3, 4]) == 6" },
      { "assert": "sum_even([1, 3, 5]) == 0" },
      { "assert": "sum_even([-2, -4, 5, 7]) == -6" },
      { "assert": "sum_even([2, 4, 6, 8, 10]) == 30" }
    ]
  },
  {
    "prompt": "Fix the bug: def add(a,b): return a - b. Return only the corrected function code.",
    "code_tests": [
      { "assert": "add(2, 3) == 5" },
      { "assert": "add(-1, 1) == 0" },
      { "assert": "add(1_000_000, -1_000_000) == 0" },
      { "assert": "add(0, 0) == 0" }
    ]
  },
  {
    "prompt": "Write a Python function add_one(x: int) -> int that returns x + 1. Return only the function code.",
    "code_tests": [
      { "assert": "add_one(0) == 1" },
      { "assert": "add_one(41) == 42" },
      { "assert": "add_one(-5) == -4" },
      { "assert": "add_one(1_000_000) == 1_000_001" }
    ]
  },
  {
    "prompt": "Write a function fib(n: int) -> int that returns the nth Fibonacci number iteratively (n>=0). Return only the function code.",
    "code_tests": [
      { "assert": "fib(0) == 0" },
      { "assert": "fib(1) == 1" },
      { "assert": "fib(10) == 55" },
      { "assert": "fib(20) == 6765" }
    ]
  },
  {
    "prompt": "Write a function factorial(n: int) -> int that returns n! for n>=0 using an iterative approach. Return only the function code.",
    "code_tests": [
      { "assert": "factorial(0) == 1" },
      { "assert": "factorial(5) == 120" },
      { "assert": "factorial(8) == 40320" }
    ]
  },
  {
    "prompt": "Write a function gcd(a: int, b: int) -> int using the Euclidean algorithm. Return only the function code.",
    "code_tests": [
      { "assert": "gcd(54, 24) == 6" },
      { "assert": "gcd(17, 13) == 1" },
      { "assert": "gcd(0, 5) == 5" }
    ]
  },
  {
    "prompt": "Write a function unique_preserve_order(items: list[int]) -> list[int] that removes duplicates while preserving first occurrence order. Return only the function code.",
    "code_tests": [
      { "assert": "unique_preserve_order([1,2,2,3,1,4]) == [1,2,3,4]" },
      { "assert": "unique_preserve_order([]) == []" },
      { "assert": "unique_preserve_order([5,5,5]) == [5]" }
    ]
  },
  {
    "prompt": "Write a function two_sum(nums: list[int], target: int) -> tuple[int,int] returning indices of two numbers that add up to target (assume one solution). Return only the function code.",
    "code_tests": [
      { "assert": "two_sum([2,7,11,15], 9) == (0, 1)" },
      { "assert": "two_sum([3,2,4], 6) == (1, 2)" },
      { "assert": "two_sum([3,3], 6) == (0, 1)" }
    ]
  },
  {
    "prompt": "Write a function flatten(nested: list[list[int]]) -> list[int] that flattens a 2D list into 1D. Return only the function code.",
    "code_tests": [
      { "assert": "flatten([[1,2],[3,4]]) == [1,2,3,4]" },
      { "assert": "flatten([[], [1], []]) == [1]" }
    ]
  },
  {
    "prompt": "Write a function rotate_left(nums: list[int], k: int) -> list[int] that rotates the list k steps to the left. Return only the function code.",
    "code_tests": [
      { "assert": "rotate_left([1,2,3,4,5], 2) == [3,4,5,1,2]" },
      { "assert": "rotate_left([1,2], 5) == [2,1]" }
    ]
  },
  {
    "prompt": "Write a function is_anagram(a: str, b: str) -> bool ignoring spaces and case. Return only the function code.",
    "code_tests": [
      { "assert": "is_anagram('Listen', 'Silent')" },
      { "assert": "is_anagram('Dormitory', 'Dirty room')" },
      { "assert": "is_anagram('Hello', 'Olelh!')" },
      { "assert": "is_anagram('Test', 'Taste') is False" }
    ]
  },
  {
    "prompt": "Write a function reverse_words(sentence: str) -> str that reverses word order but keeps words intact. Return only the function code.",
    "code_tests": [
      { "assert": "reverse_words('Hello world') == 'world Hello'" },
      { "assert": "reverse_words('  one  two   ') == 'two one'" }
    ]
  },
  {
    "prompt": "Write a function chunk_list(items: list[int], size: int) -> list[list[int]] that splits the list into chunks of given size (last chunk may be shorter). Return only the function code.",
    "code_tests": [
      { "assert": "chunk_list([1,2,3,4,5], 2) == [[1,2],[3,4],[5]]" },
      { "assert": "chunk_list([], 3) == []" }
    ]
  },
  {
    "prompt": "Write a function normalize_path(path: str) -> str that normalizes a Unix-like path by resolving '.' and '..' and removing duplicate slashes (without using pathlib). Return only the function code.",
    "code_tests": [
      { "assert": "normalize_path('/a//b/./c/../d') == '/a/b/d'" },
      { "assert": "normalize_path('///') == '/'" },
      { "assert": "normalize_path('/a/../../b') == '/b'" }
    ]
  }
]
